/*
 * lights_up.idp
 * Cedric Lefevre
 * Romeo Permentier
 * 17/05/2021
 */
vocabulary Voc {
    /* ----- TYPE ----- */
 	type R isa nat //RIJ
    type K isa nat //KOLOM
    type Getal isa int
    type I isa nat
    
    /* ----- CONSTANTE ----- */  
    
    /* ----- RELATIE ----- */
    Lamp(R,K)
    Verlicht(R,K)
    Obstakel(R, K)
    Grens(R,K,R,K)
    


    
    /* ----- FUNCTIE ----- */
    ObstakelWaarde(R,K):Getal

    
}

structure Struct : Voc {
    R = {1..7}
    K = {1..7}
    Getal = {-1..4}
    I = {1..7}
    
    
    Obstakel = {
        1,2; 1,3;
        2,7;
        3,7;
       
        5,1;
        6,1;
        7,5; 7,6;
        
    }
   
    
  
}

theory Theo : Voc {
    
//A. LAMPEN KUNNEN ELKAAR NIET VERLICHTEN
    !r1[R],r2[R], k1[K], k2[K]:
    ((r1=r2 & k1~=k2) | (r1~=r2 & k1=k2))
    &
    (Lamp(r1,k1)) 
    =>  ~Lamp(r2, k2).
//A. EEN VAKJE IS VERLICHT ALS ER EEN LAMP STAAT IN DEZELFDE RIJ OF KOLOM
    { !r1[R], k1[K],r2[R], k2[K]: Verlicht(r1,k1)<-
        (
            (k1=k2 & Lamp(r2,k2)) 
            |
            (r1=r2 & Lamp(r2,k2))
        )
        .}   
    
//B. OP EEN OBSTAKEL KAN GEEN LAMP STAAN
    ! r k: ~(Lamp(r,k) & Obstakel(r,k)).
    

    
//C. ELK VAKJE MOET VERLICHT ZIJN
    ! r,k: Verlicht(r,k).
    

    
    
    
//D. BIJHOUDEN VAN GRENZENDE VAKJES
    {	
        // ONDERSTE VAKJE
        !r1[I] k1[I] r2[I] k2[I]: Grens(r1,k1,r2,k2) <- (r1+1 = r2) & (k1=k2).
        // BOVENSTE VAKJE
        !r1[I] k1[I] r2[I] k2[I]: Grens(r1,k1,r2,k2) <- (r1-1 = r2) & (k1=k2).
        // LINKS VAKJE
        !r1[I] k1[I] r2[I] k2[I]: Grens(r1,k1,r2,k2) <- (r1 = r2) & (k1-1=k2).
        // RECHTE VAKJE
        !r1[I] k1[I] r2[I] k2[I]: Grens(r1,k1,r2,k2) <- (r1 = r2) & (k1+1=k2).
    }
    
    
//D.AAN ELK OBSTAKEL MOET HET JUIST AANTAL LAMPEN STAAN
    
    
    
    ! r k: ~Obstakel(r,k) =>  ObstakelWaarde(r,k)=0.
    
    // r1,k1 = midden
    // r2,k2 = grenzend vakje
    
    //#{r1[R], k1[K],r2[R], k2[K]: Lamp(r2,k2) & Grens(r1,k1,r2,k2) & Obstakel(r1,k1)} = 
    
    
    //#{g:Obstakel(r1,k1,g)}
    
    //.
    
    
}

procedure main() {
    stdoptions.nbmodels = 100
    printmodels(modelexpand(Theo,Struct))
}