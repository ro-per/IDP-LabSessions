include "./idp3_voc.idp"

vocabulary V_types {
    type Time
    Start : Time
    Next(Time) : Time
    
    type state
    type x isa int
    type y isa int
    type c isa int
    
    partial count(x, y) : c
    partial I_state(x, y) : state
    I_toState(x, y) : state
    n(state) : state
    empty : state
    noLight : state
    black : state
    light : state
}

LTCvocabulary V_action {
    extern vocabulary V_types

    click(Time, x, y)
}

LTCvocabulary V_state {
    extern vocabulary V_types
    toState(Time, x, y) : state
}

LTCvocabulary V {
    extern vocabulary V_state
    extern vocabulary V_action
}

vocabulary V_d3 {
    extern vocabulary idpd3::V_types
    extern vocabulary V_ss
 
    toKey(x, y) : key
    lKey(x, y) : key
    tKey(x, y) : key
    na(c) : label
}

vocabulary V_d3_in {
    extern vocabulary idpd3::V_in
    extern vocabulary V_d3
}

vocabulary V_d3_out {
    extern vocabulary idpd3::V_out
    extern vocabulary V_d3
    
    lighted(x, y)
    error(x, y)
    counted(x, y) : c
    neighbours(x, x, y, y)
}

procedure concat(a, b) {
    return a..","..b;
}
procedure lKey(a, b) {
    return "l"..a..","..b;
}
procedure tKey(a, b) {
    return "t"..a..","..b;
}
procedure name(a) {
    return a;
}


theory D3_GOL : V_d3_in {
    {
        click(x, y) <- d3_click(t, toKey(x, y)).
        click(x, y) <- d3_click(t, lKey(x, y)).
    }
    ~click(2,2).
}

theory GOL_D3 : V_d3_out {
    neighbours(x, x1, y, y1) <=> (abs(x-x1)=<1 & y=y1)| (abs(y-y1)=<1 & x=x1).
    {
        counted(x, y) = #{x1, y1 : toState(x1, y1) = light & neighbours(x, x1, y, y1)}.
    }
    {
        lighted(x, y) <- ?y1 : toState(x, y1) = light 
        			& ~(?z : (y<z<y1 | y1<z<y) & toState(x, z) = black).
        lighted(x, y) <- ?x1 : toState(x1, y) = light 
        			& ~(?z : (x<z<x1 | x1<z<x) & toState(z, y) = black).
        error(x, y) <- toState(x, y) = light & ?y1 : y~=y1 & toState(x, y1) = light 
        			& ~(?z : (y<z<y1 | y1<z<y) & toState(x, z) = black).
        error(x, y) <- toState(x, y) = light & ?x1 : x~=x1 & toState(x1, y) = light 
        			& ~(?z : (x<z<x1 | x1<z<x) & toState(z, y) = black).
        error(x, y) <- counted(x, y) ~= count(x, y) & ?c : c=count(x, y).
        
        d3_type(1, toKey(x, y)) = rect.
        d3_x(1, toKey(x, y)) = x*4.
        d3_y(1, toKey(x, y)) = y*4.
        d3_rect_width(1, toKey(x, y)) = 4.
        d3_rect_height(1, toKey(x, y)) = 4.
        d3_color(1, toKey(x, y)) = "white" <- toState(x, y) = empty & ~lighted(x, y).
        d3_color(1, toKey(x, y)) = "black" <- toState(x, y) = black.
        d3_color(1, toKey(x, y)) = "yellow" <- toState(x, y) = light.
        d3_color(1, toKey(x, y)) = "lightgray" <- toState(x, y) = noLight & ~lighted(x, y).
        d3_color(1, toKey(x, y)) = "#787800" <- toState(x, y) = noLight & lighted(x, y).
        d3_color(1, toKey(x, y)) = "yellow" <- toState(x, y) = empty & lighted(x, y).
        
        d3_type(1, lKey(x, y)) = circ <- toState(x, y) = light.
        d3_x(1, lKey(x, y)) = x*4.
        d3_y(1, lKey(x, y)) = y*4.
        d3_circ_r(1, lKey(x, y)) = 1.
        d3_color(1, lKey(x, y)) = "orange" <- ~error(x, y) & toState(x, y) = light. 
        d3_color(1, lKey(x, y)) = "red" <- error(x, y).
        
        
        d3_type(1, tKey(x, y)) = text <- ?c : c=count(x, y).
        d3_x(1, tKey(x, y)) = x*4 <- ?c : c=count(x, y).
        d3_y(1, tKey(x, y)) = 1+y*4 <- ?c : c=count(x, y).
        d3_circ_r(1, tKey(x, y)) = 3 <- ?c : c=count(x, y).
        d3_text_label(1, tKey(x, y)) = na(c) <- c = count(x, y). 
        d3_text_size(1, tKey(x, y)) = 3 <- c = count(x, y). 
        d3_color(1, tKey(x, y)) = "white" <- c = count(x, y) & ~error(x, y). 
        d3_color(1, tKey(x, y)) = "red" <- c = count(x, y) & error(x, y). 
        
        d3_link_width(a,b) =c <- false.
        d3_link_from(a,b) =c <- false.
        d3_link_to(a,b) =c <- false.
        d3_node(a,b) <- false.
        d3_isFixed(a,b) <- false.
        d3_img_path(a,b) = c <- false.
        d3_order(1, tKey(x, y)) = 1.
        d3_order(1, lKey(x, y)) = 1.
        d3_order(1, toKey(x, y)) = 0.
    }
    //~lighted(3,3).
    !t : ! x: d3_width(t) = x => ~?y : x<y.
    !t : ! x: d3_height(t) = x => ~?y : x<y.
}

theory T : V {
    {
        I_toState(x, y) = empty <- !c : I_state(x, y) ~= c.
        I_toState(x, y) = c <- I_state(x, y) = c.
        toState(Start, x, y) = I_toState(x, y). 
        toState(Next(t), x, y) = toState(t, x, y) <- ~click(t, x, y).
        toState(Next(t), x, y) = n(toState(t, x, y)) <- click(t, x, y).
    }
    //~toState(t, 1, 1) = light.
}

structure Default : V_d3 {
    x = {1..7}
    y = {1..7}
    c = {0..4}
    state = {black; empty; light; noLight}
    I_state = {
        1,3,black; 1,6,black;
        2,1,black;
        3,4,black; 3,7,black;
        4,3,black; 4,5,black;
        5,1,black; 5,4,black;
        6,7,black;
        7,2,black; 7,5,black;
    }
    count = {
        1,3,2; 1,6,2;
        2,1,0; 3,7,1; 4,3,2;
        5,1,2; 7,2,1;
    }
    n = {
        black, black;
        empty, light;
        light, noLight;
        noLight, empty;
    }
    empty = empty
    black = black
    light = light
    noLight = noLight
    
    time = {1}
    toKey = procedure concat
    lKey = procedure lKey
    tKey = procedure tKey
    na = procedure name
 
    color = {"white"; "red"; "orange"; "black"; "lightgray"; "yellow"; "#787800"}
    width = {0..62}
    height = {0..62}
}

procedure main() {
    idpd3.init_idpd3();
    stdoptions.splitdefs = false;
    stdoptions.postprocessdefs = false;
    stdoptions.cpsupport = false;
    stdoptions.xsb = false;
    idpd3_browser:setLogLevel(0);
    
    local S = clone(Default);
    local S_d3_in = clone(Default);
    local S_d3_out = clone(Default);
    setvocabulary(S, V);
    setvocabulary(S_d3_in, V_d3_in);
    setvocabulary(S_d3_out, V_d3_out);

    local coIn = idpd3_browser:createLTC(
        T, S, V_state_ss,
        D3_GOL, S_d3_in, V_d3_in,
        GOL_D3, S_d3_out, V_d3_out);
    local lastState = coIn();
}
